<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dance Line</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%239bbc0f' width='32' height='32' rx='4'/><rect fill='%230f380f' x='12' y='4' width='8' height='6'/><rect fill='%230f380f' x='10' y='10' width='12' height='10'/><rect fill='%230f380f' x='6' y='12' width='4' height='6'/><rect fill='%230f380f' x='22' y='12' width='4' height='6'/><rect fill='%230f380f' x='10' y='20' width='4' height='8'/><rect fill='%230f380f' x='18' y='20' width='4' height='8'/></svg>">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QDJKYX027L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-QDJKYX027L');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        .game-container {
            position: relative;
        }

        .screen {
            background: #9bbc0f;
            border-radius: 8px;
            padding: 12px;
            position: relative;
            overflow: visible;
            box-shadow: 
                0 0 0 4px #0f380f,
                0 0 0 8px #306230,
                0 20px 60px rgba(0,0,0,0.5),
                inset 0 0 30px rgba(0,0,0,0.15);
        }

        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.03) 2px,
                rgba(0,0,0,0.03) 4px
            );
            pointer-events: none;
            border-radius: 8px;
        }

        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            border-bottom: 3px solid #0f380f;
            margin-bottom: 10px;
        }

        .game-title {
            color: #0f380f;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .score-display {
            color: #0f380f;
            font-size: 14px;
            font-weight: bold;
        }

        .stats-group {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .help-btn {
            background: #0f380f;
            color: #9bbc0f;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s;
        }

        .help-btn:hover {
            transform: scale(1.1);
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #9bbc0f;
            border: 3px solid #0f380f;
            padding: 25px;
            text-align: center;
            display: none;
            z-index: 200;
            min-width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .overlay h2 {
            color: #0f380f;
            font-size: 20px;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .overlay p {
            color: #0f380f;
            font-size: 13px;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .overlay .highlight {
            font-weight: bold;
            font-size: 15px;
        }

        .blink-text {
            color: #0f380f;
            font-size: 11px;
            margin-top: 15px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .help-content {
            text-align: left;
        }

        .help-content h3 {
            color: #0f380f;
            font-size: 14px;
            margin: 15px 0 8px 0;
            border-bottom: 2px solid #306230;
            padding-bottom: 4px;
        }

        .help-content ul {
            list-style: none;
            padding-left: 0;
        }

        .help-content li {
            color: #0f380f;
            font-size: 12px;
            margin: 6px 0;
            padding-left: 15px;
            position: relative;
        }

        .help-content li::before {
            content: '>';
            position: absolute;
            left: 0;
            color: #306230;
        }

        .key {
            display: inline-block;
            background: #0f380f;
            color: #9bbc0f;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin: 0 2px;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Mobile controls - hidden by default, shown on touch devices */
        .mobile-controls {
            display: none;
            position: relative;
            margin-top: 40px;
            touch-action: none;
            z-index: 100;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 4px;
        }

        .dpad-btn {
            background: linear-gradient(145deg, #1a5a1a, #0f380f);
            border: 3px solid #306230;
            border-radius: 14px;
            color: #9bbc0f;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(155, 188, 15, 0.2),
                inset 0 -2px 0 rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .dpad-btn:active {
            background: linear-gradient(145deg, #0f380f, #1a5a1a);
            transform: scale(0.95);
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .dpad-btn.up { grid-column: 2; grid-row: 1; }
        .dpad-btn.left { grid-column: 1; grid-row: 2; }
        .dpad-btn.right { grid-column: 3; grid-row: 2; }
        .dpad-btn.down { grid-column: 2; grid-row: 3; }

        .dpad-center {
            grid-column: 2;
            grid-row: 2;
            background: radial-gradient(circle, #1a5a1a 0%, #0f380f 100%);
            border: 3px solid #306230;
            border-radius: 50%;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
        }

        /* Game over share buttons */
        .share-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .share-btn {
            background: #0f380f;
            color: #9bbc0f;
            border: 2px solid #306230;
            padding: 8px 16px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .share-btn:hover {
            transform: scale(1.05);
            background: #1a5a1a;
        }

        .share-btn:active {
            transform: scale(0.98);
        }

        /* Mobile styles */
        @media (pointer: coarse), (max-width: 500px) {
            body {
                min-height: 100dvh;
                justify-content: flex-start;
                padding-top: 15px;
                overflow-y: auto;
            }

            .mobile-controls {
                display: flex;
                justify-content: center;
            }

            .screen {
                padding: 8px;
                max-width: 95vw;
            }

            .screen-header {
                padding: 4px 8px;
                margin-bottom: 6px;
            }

            .game-title {
                font-size: 14px;
            }

            .score-display {
                font-size: 11px;
            }

            .stats-group {
                gap: 8px;
            }

            #gameCanvas {
                max-width: 100%;
                height: auto;
            }

            .overlay {
                padding: 15px;
                min-width: 200px;
                max-width: 90%;
                top: 55%;
            }

            .overlay h2 {
                font-size: 16px;
            }

            .overlay p {
                font-size: 11px;
            }

            .help-content h3 {
                font-size: 12px;
                margin: 10px 0 6px 0;
            }

            .help-content li {
                font-size: 11px;
            }

            .share-btn {
                padding: 6px 12px;
                font-size: 10px;
            }
        }

        @media (pointer: fine) and (min-width: 501px) {
            .help-content .touch-controls {
                display: none !important;
            }
            
            .keyboard-controls {
                display: block !important;
            }
            
            .touch-controls {
                display: none !important;
            }
        }

        .help-content .touch-controls {
            display: none;
            text-align: center;
            font-size: 13px;
            color: #0f380f;
        }

        /* Hide/show touch vs keyboard text */
        .touch-controls {
            display: none;
        }

        .keyboard-controls {
            display: block;
        }

        @media (pointer: coarse), (max-width: 500px) {
            .touch-controls {
                display: block !important;
            }

            .keyboard-controls {
                display: none !important;
            }
            
            .help-content .touch-controls {
                display: block !important;
            }
            
            .help-content .keyboard-controls {
                display: none !important;
            }
        }

        /* Hidden canvas for share image */
        #shareCanvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="screen">
            <div class="screen-header">
                <span class="game-title">DANCE LINE</span>
                <div class="header-right">
                    <div class="stats-group">
                        <span class="score-display">DANCERS: <span id="score">3</span></span>
                        <span class="score-display">RAVES: <span id="raveCount">0</span></span>
                    </div>
                    <button class="help-btn" id="helpBtn">?</button>
                </div>
            </div>
            <canvas id="gameCanvas" width="400" height="300"></canvas>
            
            <!-- Game Over Overlay -->
            <div class="overlay" id="gameOver">
                <h2>GAME OVER</h2>
                <p class="highlight">Your Line: <span id="finalDancers">0</span> Dancers</p>
                <p class="highlight">Raves Held: <span id="finalRaves">0</span></p>
                <div class="share-buttons">
                    <button class="share-btn" id="saveImageBtn">Save Image to Share</button>
                </div>
                <p class="blink-text keyboard-controls">PRESS SPACE TO PLAY AGAIN</p>
                <p class="blink-text touch-controls">TAP TO PLAY AGAIN</p>
            </div>
            
            <!-- Help Overlay -->
            <div class="overlay" id="helpOverlay">
                <h2>HOW TO PLAY</h2>
                <div class="help-content">
                    <h3>GOAL</h3>
                    <p style="text-align: center; font-size: 13px;">
                        Build the longest line possible by picking<br>
                        up dancers. For every 25 dancers there<br>
                        will be a rave.
                    </p>
                    
                    <h3>CONTROLS</h3>
                    <div class="keyboard-controls">
                        <ul>
                            <li><span class="key">Arrow Keys</span> Move your line</li>
                            <li><span class="key">SPACE</span> Pause the game</li>
                        </ul>
                    </div>
                    <div class="touch-controls">
                        <p>Use the arrow buttons to steer</p>
                        <p>Tap the screen to pause</p>
                    </div>
                    
                    <h3>RULES</h3>
                    <ul>
                        <li>Don't hit the walls</li>
                        <li>Don't crash into your own line</li>
                        <li>The longer your line, the faster you go</li>
                    </ul>
                </div>
                <p class="blink-text keyboard-controls">PRESS ANY KEY TO START</p>
                <p class="blink-text touch-controls">TAP TO START</p>
            </div>
        </div>
    </div>

    <!-- Mobile D-Pad Controls -->
    <div class="mobile-controls" id="mobileControls">
        <div class="dpad">
            <button class="dpad-btn up" id="btnUp">&#9650;</button>
            <button class="dpad-btn left" id="btnLeft">&#9664;</button>
            <div class="dpad-center"></div>
            <button class="dpad-btn right" id="btnRight">&#9654;</button>
            <button class="dpad-btn down" id="btnDown">&#9660;</button>
        </div>
    </div>

    <!-- Hidden canvas for generating share image -->
    <canvas id="shareCanvas" width="400" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const raveCountDisplay = document.getElementById('raveCount');
        const gameOverEl = document.getElementById('gameOver');
        const finalDancersEl = document.getElementById('finalDancers');
        const finalRavesEl = document.getElementById('finalRaves');
        const helpOverlay = document.getElementById('helpOverlay');
        const helpBtn = document.getElementById('helpBtn');
        const saveImageBtn = document.getElementById('saveImageBtn');
        const shareCanvas = document.getElementById('shareCanvas');
        const shareCtx = shareCanvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 12;
        const GRID_PADDING_TOP = 3; // Small padding to prevent head cutoff
        const GRID_WIDTH = Math.floor(canvas.width / GRID_SIZE);
        const GRID_HEIGHT = Math.floor((canvas.height - GRID_PADDING_TOP) / GRID_SIZE);
        
        // Colors matching green LCD screen
        const DARK_GREEN = '#0f380f';
        const MID_GREEN = '#306230';
        const LIGHT_GREEN = '#8bac0f';
        const BG_GREEN = '#9bbc0f';
        
        // Rave colors (softer, not too flashy for epilepsy safety)
        const RAVE_COLORS = [
            'rgba(255, 100, 150, 0.3)',
            'rgba(100, 150, 255, 0.3)',
            'rgba(150, 255, 100, 0.3)',
            'rgba(255, 200, 100, 0.3)',
            'rgba(200, 100, 255, 0.3)'
        ];

        // Game state
        let danceLine = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let inputQueue = []; // Queue for buffering inputs
        let newPerson = { x: 0, y: 0 };
        let gameSpeed = 150;
        let isGameOver = false;
        let isPaused = false;
        let isShowingHelp = true;
        let gameStarted = false;
        let danceFrame = 0;
        let lastUpdateTime = 0;
        let raveCount = 0;
        let lastRaveThreshold = 0;
        
        // Rave state
        let isRaving = false;
        let raveStartTime = 0;
        let raveColorIndex = 0;
        let lastRaveColorChange = 0;
        const RAVE_DURATION = 3000; // 3 seconds
        const RAVE_COLOR_INTERVAL = 300; // Change color every 300ms (slow enough to be safe)

        // Initialize game
        function init() {
            danceLine = [
                { x: 5, y: Math.floor(GRID_HEIGHT / 2) },
                { x: 4, y: Math.floor(GRID_HEIGHT / 2) },
                { x: 3, y: Math.floor(GRID_HEIGHT / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            inputQueue = [];
            isGameOver = false;
            isPaused = false;
            gameSpeed = 150;
            lastUpdateTime = performance.now();
            raveCount = 0;
            lastRaveThreshold = 0;
            isRaving = false;
            updateDancerCount();
            updateRaveCount();
            gameOverEl.style.display = 'none';
            spawnNewPerson();
        }

        function updateDancerCount() {
            scoreDisplay.textContent = danceLine.length;
        }

        function updateRaveCount() {
            raveCountDisplay.textContent = raveCount;
        }

        // Check for rave milestone
        function checkRave() {
            const currentThreshold = Math.floor(danceLine.length / 25) * 25;
            if (currentThreshold > lastRaveThreshold && currentThreshold >= 25) {
                lastRaveThreshold = currentThreshold;
                raveCount = currentThreshold / 25;
                updateRaveCount();
                triggerRave();
            }
        }

        // Trigger rave celebration
        function triggerRave() {
            isRaving = true;
            raveStartTime = performance.now();
            raveColorIndex = 0;
            lastRaveColorChange = 0;
        }

        // Spawn a new person to pick up
        function spawnNewPerson() {
            let valid = false;
            while (!valid) {
                newPerson = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
                valid = !danceLine.some(segment => 
                    segment.x === newPerson.x && segment.y === newPerson.y
                );
            }
        }

        // Draw a pixelated person
        function drawPerson(x, y, isLeader = false, index = 0) {
            const px = x * GRID_SIZE;
            const py = y * GRID_SIZE + GRID_PADDING_TOP;
            
            // Dance animation offset
            const danceOffset = Math.sin((danceFrame + index * 2) * 0.3) * 1;
            
            // Head
            ctx.fillStyle = DARK_GREEN;
            ctx.fillRect(px + 4, py + danceOffset, 4, 3);
            
            // Body
            ctx.fillRect(px + 3, py + 3 + danceOffset, 6, 5);
            
            // Arms (animated for dancing)
            const armOffset = Math.sin((danceFrame + index) * 0.5) * 1;
            ctx.fillRect(px + 1, py + 3 + armOffset, 2, 3);
            ctx.fillRect(px + 9, py + 3 - armOffset, 2, 3);
            
            // Legs
            ctx.fillRect(px + 3, py + 8, 2, 4);
            ctx.fillRect(px + 7, py + 8, 2, 4);
            
            // Leader has a special marker (hat)
            if (isLeader) {
                ctx.fillStyle = MID_GREEN;
                ctx.fillRect(px + 3, py - 2 + danceOffset, 6, 2);
            }
        }

        // Draw waiting person (the one to pick up)
        function drawWaitingPerson(x, y) {
            const px = x * GRID_SIZE;
            const py = y * GRID_SIZE + GRID_PADDING_TOP;
            
            // Jumping animation
            const jumpOffset = Math.abs(Math.sin(danceFrame * 0.2)) * 3;
            
            // Head
            ctx.fillStyle = DARK_GREEN;
            ctx.fillRect(px + 4, py - jumpOffset, 4, 3);
            
            // Body
            ctx.fillRect(px + 3, py + 3 - jumpOffset, 6, 5);
            
            // Arms up (waving)
            ctx.fillRect(px + 1, py + 1 - jumpOffset, 2, 3);
            ctx.fillRect(px + 9, py + 1 - jumpOffset, 2, 3);
            
            // Legs
            ctx.fillRect(px + 3, py + 8 - jumpOffset, 2, 4);
            ctx.fillRect(px + 7, py + 8 - jumpOffset, 2, 4);
        }

        // Main draw function
        function draw() {
            // Clear with background color
            ctx.fillStyle = BG_GREEN;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid dots (subtle)
            ctx.fillStyle = LIGHT_GREEN;
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    ctx.fillRect(x * GRID_SIZE + 5, y * GRID_SIZE + GRID_PADDING_TOP + 5, 1, 1);
                }
            }
            
            // Draw the waiting person
            drawWaitingPerson(newPerson.x, newPerson.y);
            
            // Draw the dance line
            danceLine.forEach((segment, index) => {
                drawPerson(segment.x, segment.y, index === 0, index);
            });
            
            // Draw rave overlay effect if raving
            if (isRaving) {
                const now = performance.now();
                const raveElapsed = now - raveStartTime;
                
                if (raveElapsed >= RAVE_DURATION) {
                    isRaving = false;
                } else {
                    // Change color at safe interval
                    if (now - lastRaveColorChange >= RAVE_COLOR_INTERVAL) {
                        raveColorIndex = (raveColorIndex + 1) % RAVE_COLORS.length;
                        lastRaveColorChange = now;
                    }
                    
                    // Draw color overlay
                    ctx.fillStyle = RAVE_COLORS[raveColorIndex];
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw "RAVE!" text
                    ctx.fillStyle = DARK_GREEN;
                    ctx.font = 'bold 24px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('RAVE ' + raveCount + '!', canvas.width / 2, 25);
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'alphabetic';
                }
            }
            
            danceFrame++;
        }

        // Process queued input
        function processInput() {
            if (inputQueue.length > 0) {
                const newDir = inputQueue.shift();
                // Only apply if it's not reversing direction
                if (newDir.x !== -direction.x || newDir.y !== -direction.y) {
                    nextDirection = newDir;
                }
            }
        }

        // Update game state
        function update() {
            if (isGameOver || isPaused || isShowingHelp) return;
            
            // Process any queued input
            processInput();
            
            direction = { ...nextDirection };
            
            // Calculate new head position
            const head = danceLine[0];
            const newHead = {
                x: head.x + direction.x,
                y: head.y + direction.y
            };
            
            // Check wall collision
            if (newHead.x < 0 || newHead.x >= GRID_WIDTH || 
                newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
                gameOver();
                return;
            }
            
            // Check self collision
            if (danceLine.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                gameOver();
                return;
            }
            
            // Add new head
            danceLine.unshift(newHead);
            
            // Check if we picked up new person
            if (newHead.x === newPerson.x && newHead.y === newPerson.y) {
                updateDancerCount();
                checkRave();
                spawnNewPerson();
                
                // Speed up slightly
                if (gameSpeed > 80) {
                    gameSpeed -= 2;
                }
            } else {
                // Remove tail if no pickup
                danceLine.pop();
            }
        }

        // Game over
        function gameOver() {
            isGameOver = true;
            isRaving = false;
            finalDancersEl.textContent = danceLine.length;
            finalRavesEl.textContent = raveCount;
            gameOverEl.style.display = 'block';
        }

        // Draw a person on share canvas
        function drawSharePerson(x, y, scale = 1) {
            const s = scale;
            // Head
            shareCtx.fillRect(x + 4*s, y, 4*s, 3*s);
            // Body
            shareCtx.fillRect(x + 3*s, y + 3*s, 6*s, 5*s);
            // Arms up
            shareCtx.fillRect(x + 1*s, y + 2*s, 2*s, 3*s);
            shareCtx.fillRect(x + 9*s, y + 2*s, 2*s, 3*s);
            // Legs
            shareCtx.fillRect(x + 3*s, y + 8*s, 2*s, 4*s);
            shareCtx.fillRect(x + 7*s, y + 8*s, 2*s, 4*s);
        }

        // Generate share image with smiley face made of dancers
        function generateShareImage() {
            // Set canvas size
            shareCanvas.width = 400;
            shareCanvas.height = 400;
            
            // Background
            shareCtx.fillStyle = BG_GREEN;
            shareCtx.fillRect(0, 0, shareCanvas.width, shareCanvas.height);
            
            // Border
            shareCtx.strokeStyle = DARK_GREEN;
            shareCtx.lineWidth = 8;
            shareCtx.strokeRect(4, 4, shareCanvas.width - 8, shareCanvas.height - 8);
            
            // Inner border
            shareCtx.strokeStyle = MID_GREEN;
            shareCtx.lineWidth = 4;
            shareCtx.strokeRect(12, 12, shareCanvas.width - 24, shareCanvas.height - 24);
            
            // Title
            shareCtx.fillStyle = DARK_GREEN;
            shareCtx.font = 'bold 36px "Courier New", monospace';
            shareCtx.textAlign = 'center';
            shareCtx.fillText('DANCE LINE', shareCanvas.width / 2, 55);
            
            // Score
            shareCtx.font = 'bold 28px "Courier New", monospace';
            shareCtx.fillText(danceLine.length + ' DANCERS', shareCanvas.width / 2, 95);
            
            // Raves
            shareCtx.font = 'bold 22px "Courier New", monospace';
            shareCtx.fillStyle = MID_GREEN;
            shareCtx.fillText(raveCount + ' RAVES HELD', shareCanvas.width / 2, 125);
            
            // Draw smiley face made of dancers
            shareCtx.fillStyle = DARK_GREEN;
            const centerX = shareCanvas.width / 2;
            const centerY = 230;
            const faceRadius = 80;
            
            // Draw circle outline with dancers
            const numDancers = 16;
            for (let i = 0; i < numDancers; i++) {
                const angle = (i / numDancers) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * faceRadius - 6;
                const y = centerY + Math.sin(angle) * faceRadius - 6;
                drawSharePerson(x, y, 1);
            }
            
            // Left eye (single dancer)
            drawSharePerson(centerX - 35, centerY - 15, 1.2);
            
            // Right eye (single dancer)
            drawSharePerson(centerX + 20, centerY - 15, 1.2);
            
            // Smile (arc of dancers)
            const smileDancers = 5;
            for (let i = 0; i < smileDancers; i++) {
                const angle = (i / (smileDancers - 1)) * Math.PI * 0.6 + Math.PI * 0.2;
                const x = centerX + Math.cos(angle) * 45 - 6;
                const y = centerY + 15 + Math.sin(angle) * 25 - 6;
                drawSharePerson(x, y, 1);
            }
            
            // URL/branding
            shareCtx.font = 'bold 16px "Courier New", monospace';
            shareCtx.fillStyle = DARK_GREEN;
            shareCtx.fillText('Play at:', shareCanvas.width / 2, 340);
            shareCtx.font = '14px "Courier New", monospace';
            shareCtx.fillText('dance-line.netlify.app', shareCanvas.width / 2, 360);
            
            return shareCanvas.toDataURL('image/png');
        }

        // Save image
        function saveShareImage() {
            generateShareImage();
            
            // Convert canvas to blob for sharing
            shareCanvas.toBlob(function(blob) {
                // Check if we can use native share with files (mobile)
                if (navigator.share && navigator.canShare) {
                    const file = new File([blob], 'dance-line-score.png', { type: 'image/png' });
                    const shareData = { files: [file] };
                    
                    if (navigator.canShare(shareData)) {
                        navigator.share(shareData)
                            .then(() => {
                                saveImageBtn.textContent = 'Shared!';
                                setTimeout(() => {
                                    saveImageBtn.textContent = 'Save Image to Share';
                                }, 2000);
                            })
                            .catch((err) => {
                                // User cancelled or error - fall back to download
                                if (err.name !== 'AbortError') {
                                    downloadImageFromBlob(blob);
                                }
                            });
                        return;
                    }
                }
                
                // Fallback for desktop or browsers without share API
                downloadImageFromBlob(blob);
            }, 'image/png');
        }

        function downloadImageFromBlob(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'dance-line-score.png';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            saveImageBtn.textContent = 'Saved!';
            setTimeout(() => {
                saveImageBtn.textContent = 'Save Image to Share';
            }, 2000);
        }

        // Share button handler
        saveImageBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            saveShareImage();
        });

        // Toggle help overlay
        function toggleHelp() {
            isShowingHelp = !isShowingHelp;
            helpOverlay.style.display = isShowingHelp ? 'block' : 'none';
        }

        // Queue a direction change
        function queueDirection(newDir) {
            // Get the last queued direction or current direction
            const lastDir = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : direction;
            
            // Only queue if it's not a reversal of the last direction
            if (newDir.x !== -lastDir.x || newDir.y !== -lastDir.y) {
                // Limit queue size to prevent input flooding
                if (inputQueue.length < 3) {
                    inputQueue.push(newDir);
                }
            }
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            // Close help and start game on any key
            if (isShowingHelp) {
                isShowingHelp = false;
                helpOverlay.style.display = 'none';
                if (!gameStarted) {
                    gameStarted = true;
                    init();
                }
                return;
            }
            
            if (isGameOver && e.code === 'Space') {
                init();
                return;
            }
            
            if (e.code === 'Space') {
                isPaused = !isPaused;
                if (!isPaused) {
                    lastUpdateTime = performance.now();
                }
                return;
            }
            
            if (e.code === 'Escape') {
                toggleHelp();
                return;
            }
            
            // Queue direction changes for immediate response
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    queueDirection({ x: 0, y: -1 });
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    queueDirection({ x: 0, y: 1 });
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    queueDirection({ x: -1, y: 0 });
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    queueDirection({ x: 1, y: 0 });
                    break;
            }
        });

        // Help button click
        helpBtn.addEventListener('click', () => {
            if (!isShowingHelp) {
                isPaused = true;
            }
            toggleHelp();
        });

        // Prevent scrolling with arrow keys
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        // Main game loop using requestAnimationFrame
        function gameLoop(currentTime) {
            // Calculate delta time
            const deltaTime = currentTime - lastUpdateTime;
            
            // Update game state at fixed intervals
            if (deltaTime >= gameSpeed && gameStarted && !isGameOver && !isPaused && !isShowingHelp) {
                update();
                lastUpdateTime = currentTime;
            }
            
            // Always draw (for preview behind help and smooth animations)
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        // Show help on start, draw initial preview
        helpOverlay.style.display = 'block';
        
        // Draw a preview
        danceLine = [
            { x: 5, y: Math.floor(GRID_HEIGHT / 2) },
            { x: 4, y: Math.floor(GRID_HEIGHT / 2) },
            { x: 3, y: Math.floor(GRID_HEIGHT / 2) }
        ];
        newPerson = { x: 15, y: Math.floor(GRID_HEIGHT / 2) };
        draw();
        
        // Start the game loop
        requestAnimationFrame(gameLoop);

        // ===== MOBILE D-PAD CONTROLS =====
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        function handleDpadPress(dir) {
            // Start game if showing help
            if (isShowingHelp) {
                isShowingHelp = false;
                helpOverlay.style.display = 'none';
                if (!gameStarted) {
                    gameStarted = true;
                    init();
                }
            }
            
            // Restart if game over
            if (isGameOver) {
                init();
                return;
            }
            
            // Unpause if paused
            if (isPaused) {
                isPaused = false;
                lastUpdateTime = performance.now();
            }
            
            // Queue the direction
            queueDirection(dir);
        }

        // Touch events for D-pad buttons
        btnUp.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDpadPress({ x: 0, y: -1 });
        }, { passive: false });

        btnDown.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDpadPress({ x: 0, y: 1 });
        }, { passive: false });

        btnLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDpadPress({ x: -1, y: 0 });
        }, { passive: false });

        btnRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDpadPress({ x: 1, y: 0 });
        }, { passive: false });

        // Also support click for testing on desktop
        btnUp.addEventListener('click', () => handleDpadPress({ x: 0, y: -1 }));
        btnDown.addEventListener('click', () => handleDpadPress({ x: 0, y: 1 }));
        btnLeft.addEventListener('click', () => handleDpadPress({ x: -1, y: 0 }));
        btnRight.addEventListener('click', () => handleDpadPress({ x: 1, y: 0 }));

        // Tap on screen (outside controls) to pause - for mobile
        document.addEventListener('touchstart', (e) => {
            // Ignore if touching controls, help button, or share buttons
            if (e.target.closest('#mobileControls') || 
                e.target.closest('#helpBtn') ||
                e.target.closest('.share-buttons')) {
                return;
            }
            
            // If showing help, close it and start
            if (isShowingHelp) {
                isShowingHelp = false;
                helpOverlay.style.display = 'none';
                if (!gameStarted) {
                    gameStarted = true;
                    init();
                }
                return;
            }
            
            // If game over, don't restart on tap near share buttons
            if (isGameOver) {
                if (!e.target.closest('.overlay')) {
                    init();
                }
                return;
            }
            
            // Otherwise toggle pause
            isPaused = !isPaused;
            if (!isPaused) {
                lastUpdateTime = performance.now();
            }
        }, { passive: true });
    </script>
</body>
</html>
